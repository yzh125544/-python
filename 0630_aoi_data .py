# -*- coding: utf-8 -*-
"""0630_aoi_data.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1k2y-gxaO-qHG63ucnM2iU2h-EObO8-xo
"""

# prompt: 依照所有的縣市列出所有的agi平均

import pandas as pd

# 假設您的資料已經載入到名為 df 的 Pandas DataFrame 中，
# 其中包含 '縣市' 和 'Agi' 兩個欄位。
# 例如:
# data = {'縣市': ['台北市', '新北市', '台北市', '高雄市', '新北市'],
#         'Agi': [500000, 450000, 550000, 400000, 480000]}
# df = pd.DataFrame(data)

# 如果您的資料是從 CSV 檔案載入的，可以使用以下程式碼：
# df = pd.read_csv('your_data.csv') # 請將 'your_data.csv' 替換為您的檔案路徑

# 按縣市分組並計算 Agi 的平均值
# 將 '縣市' 替換為實際的欄位名稱 'county'
# 這裡假設 Agi 對應到資料中的 'aqi' 欄位
agi_average_by_city = df.groupby('county')['aqi'].mean().reset_index()

# 重新命名欄位以便更容易理解
# 將 'county' 重新命名為 '縣市'，將 'aqi' 重新命名為 'Agi 平均'
agi_average_by_city.columns = ['縣市', 'Agi 平均']

# 依照縣市列出 Agi 平均
print("各縣市 Agi 平均:")
# 使用 display 顯示 DataFrame
display(agi_average_by_city)

# 或者，如果您想要以表格形式顯示在 Jupyter Notebook 中
# display(agi_average_by_city)

import requests
import pandas as pd

# Use the provided API URL directly
actual_data_url = "https://data.moenv.gov.tw/api/v2/aqx_p_432?api_key=e8dd42e6-9b8b-43f8-991e-b3dee723a52d&limit=1000&sort=ImportDate%20desc&format=CSV"

print(f"嘗試從這個網址下載資料： {actual_data_url}")

try:
    data_response = requests.get(actual_data_url)
    data_response.raise_for_status() # Raise an exception for bad status codes

    # Assuming the data is in CSV format based on the URL
    from io import StringIO
    data_io = StringIO(data_response.text)
    df = pd.read_csv(data_io)

    print("資料讀取成功！")

    display(df.head())

except requests.exceptions.RequestException as e:
    print(f"下載資料時發生錯誤：{e}")
    print("請確認提供的連結是否正確，以及您是否有權限存取該資料。")
except Exception as e:
    print(f"讀取資料時發生錯誤：{e}")
    print("請確認資料格式是否為 CSV，或嘗試使用適合的 Pandas 讀取函式 (例如 read_excel)。")

"""**請注意：**

*   上面的程式碼嘗試從一個假設的直接下載連結下載資料。您需要手動前往 [https://data.gov.tw/dataset/40448](https://data.gov.tw/dataset/40448) 這個頁面，找到實際的資料下載連結，並將程式碼中的 `actual_data_url` 變數替換為該連結。
*   如果資料不是 CSV 格式，您需要使用 Pandas 中對應的讀取函式 (例如 `pd.read_excel`)。

在您更新了 `actual_data_url` 變數並確認資料格式後，請再次執行上面的程式碼儲存格。
"""

# 安裝支援中文的字體
!apt-get update -qq > /dev/null
!apt-get install fonts-noto-cjk -qq > /dev/null

# 找出 AQI 最高的測站
# 首先確保 'aqi' 欄位是數值類型，並處理潛在的非數值資料
df['aqi'] = pd.to_numeric(df['aqi'], errors='coerce')

# 移除 AQI 為 NaN 的列，以免影響排序
df_cleaned = df.dropna(subset=['aqi'])

# 根據 AQI 值降序排序
highest_aqi_stations = df_cleaned.sort_values(by='aqi', ascending=False)

print("AQI 最高的測站：")
# 顯示 AQI 最高的幾個測站 (例如前 10 個)
display(highest_aqi_stations.head(10))

# 計算不同縣市的污染物平均值

# 確保相關污染物欄位是數值類型，並處理潛在的非數值資料
pollutant_columns = ['aqi', 'so2', 'co', 'o3', 'o3_8hr', 'pm10', 'pm2.5', 'nox', 'no', 'no2', 'wind_speed', 'wind_direc', 'co_8hr', 'pm2.5_avg', 'pm10_avg', 'so2_avg']
for col in pollutant_columns:
    if col in df.columns:
        df[col] = pd.to_numeric(df[col], errors='coerce')

# 移除縣市為 NaN 的列
df_cleaned_county = df.dropna(subset=['county'])

# 按縣市分組並計算污染物平均值
county_avg_pollutants = df_cleaned_county.groupby('county')[pollutant_columns].mean()

# 定義欄位名稱的中文對應
chinese_column_names = {
    'aqi': '空氣品質指數(AQI)',
    'so2': '二氧化硫(SO2)',
    'co': '一氧化碳(CO)',
    'o3': '臭氧(O3)',
    'o3_8hr': '臭氧8小時(O3_8hr)',
    'pm10': '懸浮微粒(PM10)',
    'pm2.5': '細懸浮微粒(PM2.5)',
    'nox': '氮氧化物(NOx)',
    'no': '一氧化氮(NO)',
    'no2': '二氧化氮(NO2)',
    'wind_speed': '風速',
    'wind_direc': '風向',
    'co_8hr': '一氧化碳8小時(CO_8hr)',
    'pm2.5_avg': '細懸浮微粒平均(PM2.5_avg)',
    'pm10_avg': '懸浮微粒平均(PM10_avg)',
    'so2_avg': '二氧化硫平均(SO2_avg)'
}

# 重新命名欄位
county_avg_pollutants = county_avg_pollutants.rename(columns=chinese_column_names)


print("不同縣市的污染物平均值：")
# 使用 display 顯示 DataFrame，並設定浮點數顯示格式
with pd.option_context('display.float_format', '{:.2f}'.format):
    display(county_avg_pollutants)

import matplotlib.pyplot as plt
import seaborn as sns
import matplotlib.font_manager as fm

# Use the font properties from the previous successful attempt (assuming Noto Sans CJK JP is available and set)
# If the previous font setting was successful, matplotlib should retain the font configuration.
# However, to be safe and ensure Chinese characters are rendered, we can explicitly set font properties again,
# or rely on the global rcParams if they were set correctly in a previous executed cell.

# Re-checking for the Chinese font and setting font properties as a robust measure
chinese_font = None
for font in fm.fontManager.ttflist:
    if 'Noto Sans CJK' in font.name or 'Arial Unicode MS' in font.name or 'SimSun' in font.name:
        chinese_font = font
        break

if chinese_font:
    prop = fm.FontProperties(fname=chinese_font.fname)
    font_name = prop.get_name()

    # Set the font for all text elements
    plt.rcParams['font.family'] = font_name
    plt.rcParams['axes.unicode_minus'] = False # Resolve the negative sign issue

    print(f"Using font: {font_name}")

    plt.figure(figsize=(12, 7)) # Adjust figure size for better readability of county names
    # Plotting the average PM2.5 per county
    sns.barplot(x=county_avg_pollutants.index, y=county_avg_pollutants['pm2.5_avg'], palette='viridis') # Using pm2.5_avg as it's available
    plt.title('各縣市平均細懸浮微粒 (PM2.5)', fontproperties=prop)
    plt.xlabel('縣市', fontproperties=prop)
    plt.ylabel('平均 PM2.5 (微克/立方公尺)', fontproperties=prop)
    plt.xticks(rotation=45, ha='right', fontproperties=prop) # Rotate labels and align them to the right
    plt.yticks(fontproperties=prop) # Also set for y-axis tick labels
    plt.tight_layout() # Adjust layout to prevent labels overlapping
    plt.show()
else:
     print("Warning: Could not find a suitable Chinese font. Plotting with default font.")
     plt.figure(figsize=(12, 7))
     sns.barplot(x=county_avg_pollutants.index, y=county_avg_pollutants['pm2.5_avg'], palette='viridis')
     plt.title('各縣市平均細懸浮微粒 (PM2.5)')
     plt.xlabel('縣市')
     plt.ylabel('平均 PM2.5 (微克/立方公尺)')
     plt.xticks(rotation=45, ha='right')
     plt.tight_layout()
     plt.show()

# 找出平均 AQI 最高和最低的縣市

# 確保 county_avg_pollutants DataFrame 已經計算出來
if 'county_avg_pollutants' in locals():
    # 根據平均 AQI 排序
    county_avg_sorted = county_avg_pollutants.sort_values(by='aqi', ascending=False)

    print("平均 AQI 最高的縣市 (相對「最髒」)：")
    # 顯示平均 AQI 最高的縣市 (第一個)
    display(county_avg_sorted.head(1))

    print("\n平均 AQI 最低的縣市 (相對「最乾淨」)：")
    # 顯示平均 AQI 最低的縣市 (最後一個)
    display(county_avg_sorted.tail(1))
else:
    print("錯誤：找不到 county_avg_pollutants 這個 DataFrame。請確認您已經執行了計算縣市污染物平均值的程式碼。")

# 按縣市和空氣品質狀態分組並計算數量
county_status_distribution = df.groupby(['county', 'status']).size().unstack(fill_value=0)

print("不同縣市的空氣品質狀態分佈：")
display(county_status_distribution)

# 您也可以將這個分佈視覺化，例如使用堆疊長條圖
# import matplotlib.pyplot as plt
# import seaborn as sns
# import matplotlib.font_manager as fm

# # Re-checking for the Chinese font and setting font properties
# chinese_font = None
# for font in fm.fontManager.ttflist:
#     if 'Noto Sans CJK' in font.name or 'Arial Unicode MS' in font.name or 'SimSun' in font.name:
#         chinese_font = font
#         break

# if chinese_font:
#     prop = fm.FontProperties(fname=chinese_font.fname)
#     font_name = prop.get_name()
#     plt.rcParams['font.family'] = font_name
#     plt.rcParams['axes.unicode_minus'] = False

#     plt.figure(figsize=(15, 8)) # Adjust figure size
#     county_status_distribution.plot(kind='bar', stacked=True, figsize=(15, 8), fontproperties=prop)
#     plt.title('各縣市空氣品質狀態分佈', fontproperties=prop)
#     plt.xlabel('縣市', fontproperties=prop)
#     plt.ylabel('測站數量', fontproperties=prop)
#     plt.xticks(rotation=45, ha='right', fontproperties=prop)
#     plt.yticks(fontproperties=prop)
#     plt.legend(title='狀態', bbox_to_anchor=(1.05, 1), loc='upper left', prop=prop) # Adjust legend position
#     plt.tight_layout()
#     plt.show()
# else:
#     print("Warning: Could not find a suitable Chinese font. Plotting with default font.")
#     plt.figure(figsize=(15, 8))
#     county_status_distribution.plot(kind='bar', stacked=True, figsize=(15, 8))
#     plt.title('各縣市空氣品質狀態分佈')
#     plt.xlabel('縣市')
#     plt.ylabel('測站數量')
#     plt.xticks(rotation=45, ha='right')
#     plt.legend(title='狀態', bbox_to_anchor=(1.05, 1), loc='upper left')
#     plt.tight_layout()
#     plt.show()

import matplotlib.pyplot as plt
import seaborn as sns
import matplotlib.font_manager as fm

# 使用之前成功設定的字體屬性
chinese_font = None
for font in fm.fontManager.ttflist:
    if 'Noto Sans CJK' in font.name or 'Arial Unicode MS' in font.name or 'SimSun' in font.name:
        chinese_font = font
        break

if chinese_font:
    prop = fm.FontProperties(fname=chinese_font.fname)
    font_name = prop.get_name()
    plt.rcParams['font.family'] = font_name
    plt.rcParams['axes.unicode_minus'] = False
    print(f"Using font: {font_name}")

    plt.figure(figsize=(15, 8)) # Adjust figure size
    ax = plt.gca() # Get the current axes

    # Plot using pandas plot method
    county_status_distribution.plot(kind='bar', stacked=True, ax=ax, figsize=(15, 8)) # Removed fontproperties from here

    plt.title('各縣市空氣品質狀態分佈', fontproperties=prop)
    plt.xlabel('縣市', fontproperties=prop)
    plt.ylabel('測站數量', fontproperties=prop)

    # Set font properties for x and y tick labels
    for label in ax.get_xticklabels():
        label.set_fontproperties(prop)
    for label in ax.get_yticklabels():
        label.set_fontproperties(prop)

    plt.xticks(rotation=45, ha='right') # Keep rotation and alignment
    # plt.yticks(fontproperties=prop) # Removed fontproperties

    plt.legend(title='狀態', bbox_to_anchor=(1.05, 1), loc='upper left', prop=prop) # Adjust legend position and set font for legend text
    plt.tight_layout() # Adjust layout to prevent labels overlapping
    plt.show()
else:
    print("Warning: Could not find a suitable Chinese font. Plotting with default font.")
    plt.figure(figsize=(15, 8))
    ax = plt.gca()
    county_status_distribution.plot(kind='bar', stacked=True, ax=ax, figsize=(15, 8))
    plt.title('各縣市空氣品質狀態分佈')
    plt.xlabel('縣市')
    plt.ylabel('測站數量')
    plt.xticks(rotation=45, ha='right')
    plt.legend(title='狀態', bbox_to_anchor=(1.05, 1), loc='upper left')
    plt.tight_layout()
    plt.show()